// Base class [for later use]
class AetheriusBaseZSC : Actor
{
 int user_theta, user_dormant, user_isstealth, user_basespeed, user_baseattack, user_basedefense, user_basemass, user_monsterlevel, user_legendaryevolved, user_extraevolvechance, user_extrastealthchance;
 int user_MaxHP, user_HPCritRange, user_HPBuffRange, user_HPXDeathRange, user_HPXDeathRange2, user_HPLowRange;
 int user_checkmapskill, user_ressurrectstr, user_resurrectedtimes, user_canusecrisisatk;
 int user_barragecounter, user_shotsfired, user_shotsfiredmax;
 float user_shotaccuracy, user_shotaccuracy1, user_shotaccuracy2; 
 float user_shotzaccuracy, user_shotzaccuracy1, user_shotzaccuracy2; 
 float user_randominaccuracy, user_randominaccuracy2;
 int user_pelletsfired, user_currenttracer, user_aimangleorigin; 
 int user_ammotype, user_gravitytype, user_shotangle, user_chargeinterval, user_pulseinterval;
 int user_spread, user_spread1, user_spread2;
 int user_attacktype, user_attacks, user_attackmax, user_fastchasechance;
 int user_paintomissile;

 int user_defendtimer, user_defendtimermax, user_defendcycles;
 int user_autorestimer;
 int user_firevolleys, user_firevolleymax;
 int user_random, user_random1, user_ailment1, user_ailmentmaxchance, user_attackpoint;
 int user_chargechange; 
 int user_healthset, user_healthmoderaterange, user_healthlowrange;
 int user_charmchance;
 int user_regencycles, user_regencyclemax;
}

// Base Projectile Class
class AetheriusProjectileZSC : AetheriusBaseZSC
{
    // Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}
}

// Base monster class [for later use, general monster use outside of game]
class AetheriusMonsterZSC : AetheriusBaseZSC
{
 // Gargoyle
 bool extremecrash;
 // Afrit
 const FIREDEMON_ATTACK_RANGE = 64*8.;
 int fdstrafecount;
 // Bishop
 int missilecount;
 int bobstate;

 // General
 int painchancefist, painchancekick, painchancegauntlets;

 default
 {
  Painchance "GravityHP", 256;
  Painchance "GravityMP", 256;
  Painchance "GravityHPMP", 256;
 }
 //****************************
 //*AETHERIUS UNIQUE FUNCTIONS*
 //****************************
 void A_MonsterCrisisCheck ()
 {
  user_canusecrisisatk = 0;
  if(health <= user_HPLowRange) { if(health <= user_HPCritRange) { user_canusecrisisatk = 1; } else { if (random(1,4) == 4) { user_canusecrisisatk = 1;	} } }
  if(GetCVar("dvds_monstercrisisattacks") == 0) { user_canusecrisisatk = 0; }
 }

 void A_PlayCrisisAtkSound ()
 {
  A_PlaySound("crisisattack",6);
  A_PlaySound("crisisattack2",7);
 }

 void A_CrisisMushroom (Class<Actor> missiletype, Class<Actor> crisismissiletype, int amount = 0, int flags = 0, float vrange = 4.0, float hrange = 0.5)
 {
  if(user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); A_MushRoom(crisismissiletype,amount,vrange,hrange); }
  else { A_MushRoom(missiletype,amount,flags,vrange,hrange); }  
 }
 
 void A_CrisisSpawnProjectile (Class<Actor> missiletype, Class<Actor> crisismissiletype, float spawnheight = 32.0, float spawnofs_xy = 0.0, double angle = 0.0, int flags = 0, double pitch = 0, int ptr = AAPTR_TARGET)
 {
  if(user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); A_SpawnProjectile(crisismissiletype,spawnheight,spawnofs_xy,angle,flags,pitch,ptr); }
  else { A_SpawnProjectile(missiletype,spawnheight,spawnofs_xy,angle,flags,pitch,ptr); }
 }

 void A_CrisisBulletAttack(float horz_spread, float vert_spread, int numbullets, int damageperbullet, string pufftype = "BulletPuff", float range = 2048.0, int flags = 0, int ptr = AAPTR_TARGET, string missile = "none", float spawnheight = 32.0, float Spawnofs_xy = 0.0)
 {
  if(user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); damageperbullet *= CallACS("CrisisMultiplier"); }
  for (int i = 0; i < numbullets; i++) { A_CustomBulletAttack(horz_spread,vert_spread,1,damageperbullet,pufftype,range,flags,ptr,missile,spawnheight,Spawnofs_xy); }
 }
 
 void A_CrisisRailgun(int damage, int spawnofs_xy = 0, color ringcolor = 0, color corecolor = 0, int flags = 0, int aim = 0, double maxdiff = 0, string pufftype = "", double spread_xy = 0.0, double spread_z = 0.0, int range = 8192, int duration = 35, double sparsity = 1.0, double driftspeed = 1.0, string spawnclass = "", double spawnofs_z = 0.0, int spiraloffset = 270, int limit = 0, double veleffect = 3.0)
 {
  if(user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); damage *= CallACS("CrisisMultiplier"); }
  A_CustomRailgun(damage,spawnofs_xy,ringcolor,corecolor,flags,aim,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit,veleffect);
 }
 
 void A_CrisisComboAttack(Class<Actor> missiletype, Class<Actor> crisismissiletype, float spawnheight = 32.0, int meleedamage = 0, string meleesound = "imp/melee", string damagetype = "Melee", bool bleed = 1)
 {
  if(user_canusecrisisatk == 1) 
  {
   A_PlayCrisisAtkSound(); meleedamage *= CallACS("CrisisMultiplier"); 
   A_CustomComboAttack(crisismissiletype,spawnheight,meleedamage,meleesound,damagetype,bleed);
  }
  else
  {
   A_CustomComboAttack(missiletype,spawnheight,meleedamage,meleesound,damagetype,bleed);
  }
 }

 void A_CrisisMeleeAttack(int meleedamage, string meleesound = "", string misssound = "", string damagetype = "Melee", bool bleed = 1)
 {
  if(user_canusecrisisatk == 1) { A_PlayCrisisAtkSound(); meleedamage *= CallACS("CrisisMultiplier"); }
  A_CustomMeleeAttack(meleedamage,meleesound,misssound,damagetype,bleed);
 } 

    //**************************
    //*HERETIC-UNIQUE FUNCTIONS*
    //**************************
	// Gargoyle
	void A_ImpMsAttack()
	{
		if (!target || random[ImpMSAtk]() > 64)
		{
			SetState (SeeState);
			return;
		}
		A_SkullAttack(12);
	}

	void A_ImpExplode()
	{
		Actor chunk;

		bNoGravity = false;

		chunk = Spawn("HereticImpChunk1", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}

		chunk = Spawn("HereticImpChunk2", pos, ALLOW_REPLACE);
		if (chunk != null)
		{
			chunk.vel.x = random2[ImpExplode]() / 64.;
			chunk.vel.y = random2[ImpExplode]() / 64.;
			chunk.vel.z = 9;
		}
		
		if (extremecrash)
		{
			SetStateLabel ("XCrash");
		}
	}

 	void A_ImpDeath()
	{
		bSolid = false;
		bFloorClip = true;
	}

	void A_ImpXDeath1()
	{
		bSolid = false;
		bFloorClip = true;
		bNoGravity = true;
		extremecrash = true;
	}

	// Knight
	void A_KnightAttack ()
	{
		if (!target) return;
		if (CheckMeleeRange ())
		{
			int damage = random[KnightAttack](1, 8) * 3;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			A_PlaySound ("hknight/melee", CHAN_BODY);
			return;
		}
		// Throw axe
		A_PlaySound (AttackSound, CHAN_BODY);
		if (self.bShadow || random[KnightAttack]() < 40)
		{ // Red axe
			SpawnMissileZ (pos.Z + 36, target, "RedAxe");
		}
		else
		{ // Green axe
			SpawnMissileZ (pos.Z + 36, target, "KnightAxe");
		}
	}

	// Disciple
	void A_GhostOff ()
	{
		A_SetRenderStyle(1.0, STYLE_Normal);
		bGhost = false;
	}

	void A_WizAtk1 ()
	{
		A_FaceTarget ();
		A_GhostOff();
	}

	void A_WizAtk2 ()
	{
		A_FaceTarget ();
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
		bGhost = true;
	}

	void A_WizAtk3 ()
	{
		A_GhostOff();
		if (!target) return;
		A_PlaySound (AttackSound, CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = random[WizAtk3](1, 8) * 4;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		Actor mo = SpawnMissile (target, "WizardFX1");
		if (mo != null)
		{
			SpawnMissileAngle("WizardFX1", mo.Angle - 45. / 8, mo.Vel.Z);
			SpawnMissileAngle("WizardFX1", mo.Angle + 45. / 8, mo.Vel.Z);
		}
	}

	// Iron Lich
	void A_LichAttack (int fireshots = 5, int tornados = 1)
	{
		static const int atkResolve1[] = { 50, 150 };
		static const int atkResolve2[] = { 150, 200 };

		// Ice ball		(close 20% : far 60%)
		// Fire column	(close 40% : far 20%)
		// Whirlwind	(close 40% : far 20%)
		// Distance threshold = 8 cells

		if (target == null)
		{
			return;
		}
		A_FaceTarget ();
		if (CheckMeleeRange ())
		{
			int damage = random[LichAttack](1, 8) * 6;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		int dist = Distance2D(target) > 8 * 64;
		int randAttack = random[LichAttack]();
		if (randAttack < atkResolve1[dist])
		{ // Ice ball
			SpawnMissile (target, "HeadFX1");
			A_PlaySound ("ironlich/attack2", CHAN_BODY);
		}
		else if (randAttack < atkResolve2[dist])
		{ // Fire column
			Actor baseFire = SpawnMissile (target, "HeadFX3");
			if (baseFire != null)
			{
				baseFire.SetStateLabel("NoGrow");
				for (int i = 0; i < fireshots; i++)
				{
					Actor fire = Spawn("HeadFX3", baseFire.Pos, ALLOW_REPLACE);
					if (i == 0)
					{
						A_PlaySound ("ironlich/attack1", CHAN_BODY);
					}
					if (fire != null)
					{
						fire.target = baseFire.target;
						fire.angle = baseFire.angle;
						fire.Vel = baseFire.Vel;
						fire.SetDamage(0);
						fire.health = (i+1) * 2;
						fire.CheckMissileSpawn (radius);
					}
				}
			}
		}
		else
		{ // Whirlwind
		  for (int i = 0; i < tornados; i++)
		  {
			Actor mo = SpawnMissile (target, "Whirlwind");
			if (mo != null)
			{
				mo.AddZ(-32+(i*16));
				mo.tracer = target;
				mo.health = 20*TICRATE; // Duration
				A_PlaySound ("ironlich/attack3", CHAN_BODY);
			}
		  }
		}
	}

	//************************
    //*HEXEN-UNIQUE FUNCTIONS*
    //************************
    // Centaur
	void A_CentaurDefend()
	{
		A_FaceTarget ();
		if (CheckMeleeRange() && random[CentaurDefend]() < 32)
		{
			// This should unset REFLECTIVE as well
			// (unless you want the Centaur to reflect projectiles forever!)
			bReflective = false;
			bInvulnerable = false;
			SetState(MeleeState);
		}
	}

    // Afrit
	private void A_FiredSpawnRock ()
	{
		Actor mo;
		class<Actor> rtype;

		switch (random[FireDemonRock](0, 4))
		{
			case 0:
				rtype = "FireDemonRock1";
				break;
			case 1:
				rtype = "FireDemonRock2";
				break;
			case 2:
				rtype = "FireDemonRock3";
				break;
			case 3:
				rtype = "FireDemonRock4";
				break;
			case 4:
			default:
				rtype = "FireDemonRock5";
				break;
		}

		double xo = (random[FireDemonRock]() - 128) / 16.;
		double yo = (random[FireDemonRock]() - 128) / 16.;
		double zo = random[FireDemonRock]() / 32.;
		mo = Spawn (rtype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.target = self;
			mo.Vel.X = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Y = (random[FireDemonRock]() - 128) / 64.;
			mo.Vel.Z = (random[FireDemonRock]() / 64.);
			mo.special1 = 2;		// Number bounces
		}

		// Initialize fire demon
		fdstrafecount = 0;
		bJustAttacked = false;
	}

	void A_FiredRocks()
	{
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
		A_FiredSpawnRock ();
	}

	void A_FiredAttack()
	{
		if (target == null)	return;
		Actor mo = SpawnMissile (target, "FireDemonMissile");
		if (mo) A_PlaySound ("FireDemonAttack", CHAN_BODY);
	}

	void A_FiredChase()
	{
		int weaveindex = special1;
		double ang;
		double dist;

		if (reactiontime) reactiontime--;
		if (threshold) threshold--;

		// Float up and down
		AddZ(BobSin(weaveindex));
		special1 = (weaveindex + 2) & 63;

		// Ensure it stays above certain height
		if (pos.Z < floorz + 64)
		{
			AddZ(2);
		}

		if(!target || !target.bShootable)
		{	// Invalid target
			LookForPlayers (true);
			return;
		}

		// Strafe
		if (fdstrafecount > 0)
		{
			fdstrafecount--;
		}
		else
		{
			fdstrafecount = 0;
			Vel.X = Vel.Y = 0;
			dist = Distance2D(target);
			if (dist < FIREDEMON_ATTACK_RANGE)
			{
				if (random[FiredChase]() < 30)
				{
					ang = AngleTo(target);
					if (random[FiredChase]() < 128)
						ang += 90;
					else
						ang -= 90;
					Thrust(8, ang);
					fdstrafecount = 3;		// strafe time
				}
			}
		}

		FaceMovementDirection ();

		// Normal movement
		if (!fdstrafecount)
		{
			if (--movecount<0 || !MonsterMove ())
			{
				NewChaseDir ();
			}
		}

		// Do missile attack
		if (!bJustAttacked)
		{
			if (CheckMissileRange () && (random[FiredChase]() < 20))
			{
				SetState (MissileState);
				bJustAttacked = true;
				return;
			}
		}
		else
		{
			bJustAttacked = false;
		}

		// make active sound
		if (random[FiredChase]() < 3)
		{
			PlayActiveSound ();
		}
	}

	void A_FiredSplotch()
	{
		Actor mo;

		mo = Spawn ("FireDemonSplotch1", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
		mo = Spawn ("FireDemonSplotch2", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel.X = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Y = (random[FireDemonSplotch]() - 128) / 32.;
			mo.Vel.Z = (random[FireDemonSplotch]() / 64.) + 3;
		}
	}
	
    // Bishop
	void A_BishopAttack()
	{
		if (!target)
		{
			return;
		}
		A_PlaySound (AttackSound, CHAN_BODY);
		if (CheckMeleeRange())
		{
			int damage = random[BishopAttack](1, 8) * 4;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		missilecount = (random[BishopAttack]() & 3) + 5;
	}

	void A_BishopAttack2()
	{
		if (!target || !missilecount)
		{
			missilecount = 0;
			SetState (SeeState);
			return;
		}
		Actor mo = SpawnMissile (target, "BishopFX");
		if (mo != null)
		{
			mo.tracer = target;
		}
		missilecount--;
		return;
	}
	
	void A_BishopDecide()
	{
		if (random[BishopDecide]() >= 220)
		{
			SetStateLabel ("Blur");
		}
	}

	void A_BishopDoBlur()
	{
		missilecount = (random[BishopDoBlur]() & 3) + 3; // Random number of blurs
		if (random[BishopDoBlur]() < 120)
		{
			Thrust(11, Angle + 90);
		}
		else if (random[BishopDoBlur]() > 125)
		{
			Thrust(11, Angle - 90);
		}
		else
		{ // Thrust forward
			Thrust(11);
		}
		A_PlaySound ("BishopBlur", CHAN_BODY);
	}

	void A_BishopSpawnBlur()
	{
		if (!--missilecount)
		{
			Vel.XY = (0,0);// = Vel.Y = 0;
			if (random[BishopSpawnBlur]() > 96)
			{
				SetState (SeeState);
			}
			else
			{
				SetState (MissileState);
			}
		}
		Actor mo = Spawn ("BishopBlur", Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	void A_BishopChase()
	{
		double newz = pos.z - BobSin(bobstate) / 2.;
		bobstate = (bobstate + 4) & 63;
		newz += BobSin(bobstate) / 2.;
		SetZ(newz);
	}

	void A_BishopPainBlur()
	{
		if (random[BishopPainBlur]() < 64)
		{
			SetStateLabel ("Blur");
			return;
		}
		double xo = random2[BishopPainBlur]() / 16.;
		double yo = random2[BishopPainBlue]() / 16.;
		double zo = random2[BishopPainBlue]() / 32.;
		Actor mo = Spawn ("BishopPainBlur", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		if (mo)
		{
			mo.angle = angle;
		}
	}

	// Stalker
	void A_SerpentUnHide()
	{
		bInvisible = false;
		Floorclip = 24;
	}
	void A_SerpentHide()
	{
		bInvisible = true;
		Floorclip = 0;
	}

	void A_SerpentRaiseHump()
	{
		Floorclip -= 4;
	}
	void A_SerpentLowerHump()
	{
		Floorclip += 4;
	}
	void A_SerpentHumpDecide()
	{
		if (MissileState != NULL)
		{
			if (random[SerpentHump]() > 30)
			{
				return;
			}
			else if (random[SerpentHump]() < 40)
			{ // Missile attack
				SetState (MeleeState);
				return;
			}
		}
		else if (random[SerpentHump]() > 3)
		{
			return;
		}
		if (!CheckMeleeRange ())
		{ // The hump shouldn't occur when within melee range
			if (MissileState != NULL && random[SerpentHump]() < 128)
			{
				SetState (MeleeState);
			}
			else
			{	
				SetStateLabel("Hump");
				A_PlaySound ("SerpentActive", CHAN_BODY);
			}
		}
	}
	
	void A_SerpentCheckForAttack()
	{
		if (!target)
		{
			return;
		}
		if (MissileState != NULL)
		{
			if (!CheckMeleeRange ())
			{
				SetStateLabel ("Attack");
				return;
			}
		}
		if (CheckMeleeRange2 ())
		{
			SetStateLabel ("Walk");
		}
		else if (CheckMeleeRange ())
		{
			if (random[SerpentAttack]() < 32)
			{
				SetStateLabel ("Walk");
			}
			else
			{
				SetStateLabel ("Attack");
			}
		}
	}

	void A_SerpentChooseAttack()
	{
		if (!target || CheckMeleeRange())
		{
			return;
		}
		if (MissileState != NULL)
		{
			SetState (MissileState);
		}
	}

	void A_SerpentMeleeAttack()
	{
		if (!target)
		{
			return;
		}
		if (CheckMeleeRange ())
		{
			int damage = random[SerpentAttack](1, 8) * 5;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			A_PlaySound ("SerpentMeleeHit", CHAN_BODY);
		}
		if (random[SerpentAttack]() < 96)
		{
			A_SerpentCheckForAttack();
		}
	}

	void A_SerpentSpawnGibs()
	{
		static const class<Actor> GibTypes[] =
		{
			"SerpentGib3",
			"SerpentGib2",
			"SerpentGib1"
		};

		for (int i = 2; i >= 0; --i)
		{
			double x = (random[SerpentGibs]() - 128) / 16.;
			double y = (random[SerpentGibs]() - 128) / 16.;

			Actor mo = Spawn (GibTypes[i], Vec2OffsetZ(x, y, floorz + 1), ALLOW_REPLACE);
			if (mo)
			{
				mo.Vel.X = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Vel.Y = (random[SerpentGibs]() - 128) / 1024.f;
				mo.Floorclip = 6;
			}
		}
	}

    // Reiver
	void A_WraithInit()
	{
		AddZ(48);

		// [RH] Make sure the wraith didn't go into the ceiling
		if (pos.z + height > ceilingz)
		{
			SetZ(ceilingz - Height);
		}

		WeaveIndexZ = 0;			// index into floatbob
	}

	void A_WraithChase()
	{
		int weaveindex = WeaveIndexZ;
		AddZ(BobSin(weaveindex));
		WeaveIndexZ = (weaveindex + 2) & 63;
		A_Chase ();
		A_WraithFX4 ();
	}

	void A_WraithFX3()
	{
		int numdropped = random[WraithFX3](0,14);

		while (numdropped-- > 0)
		{
			double xo = (random[WraithFX3]() - 128) / 32.;
			double yo = (random[WraithFX3]() - 128) / 32.;
			double zo = random[WraithFX3]() / 64.;

			Actor mo = Spawn("WraithFX3", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}

	void A_WraithFX4 ()
	{
		int chance = random[WraithFX4]();
		bool spawn4, spawn5;

		if (chance < 10)
		{
			spawn4 = true;
			spawn5 = false;
		}
		else if (chance < 20)
		{
			spawn4 = false;
			spawn5 = true;
		}
		else if (chance < 25)
		{
			spawn4 = true;
			spawn5 = true;
		}
		else
		{
			spawn4 = false;
			spawn5 = false;
		}

		if (spawn4)
		{
			double xo = (random[WraithFX4]() - 128) / 16.;
			double yo = (random[WraithFX4]() - 128) / 16.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX4", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
		if (spawn5)
		{
			double xo = (random[WraithFX4]() - 128) / 32.;
			double yo = (random[WraithFX4]() - 128) / 32.;
			double zo = (random[WraithFX4]() / 64.);

			Actor mo = Spawn ("WraithFX5", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.floorz = floorz;
				mo.ceilingz = ceilingz;
				mo.target = self;
			}
		}
	}
	
	void A_WraithMelee(int drainamount)
	{
	    int maxdrain;
		if (drainamount == 0) drainamount = random[StealHealth](1,8)*2;
	    if (user_MaxHP <= 0) maxdrain = spawnhealth(); else maxdrain = user_MaxHP;
		// Steal health from target and give to self
		if (CheckMeleeRange() && (random[StealHealth]()<maxdrain))
		{
			int amount = drainamount;
			target.DamageMobj (self, self, amount, 'Melee');
			if (health < maxdrain && target.bINVULNERABLE == 0)
			{
			 health += amount;
			 if (health > maxdrain) health = maxdrain;
			}
			
		}
	}

	void A_WraithRaiseInit()
	{
		bInvisible = false;
		bNonShootable = false;
		bDontBlast = false;
		bShootable = true;
		bSolid = true;
		Floorclip = Height;
	}

	void A_WraithRaise()
	{
		if (RaiseMobj (2))
		{
			// Reached it's target height
			// [RH] Once a buried wraith is fully raised, it should be
			// morphable, right?
			bDontMorph = false;
			bSpecialFloorClip = false;
			SetStateLabel ("Chase");
			// [RH] Reset PainChance to a normal wraith's.
			PainChance = GetDefaultByType("Wraith").PainChance;
		}

		SpawnDirt (radius);
	}

	// Wendigo
	private void SpawnWisp()
	{
		static const class<Actor> WispTypes[] = { "IceGuyWisp1", "IceGuyWisp2" };

		double dist = (random[IceGuyLook]() - 128) * radius / 128.;
		double an = angle + 90;
		Actor mo = Spawn(WispTypes[random[IceGuyLook]() & 1], Vec3Angle(dist, an, 60.), ALLOW_REPLACE);
		if (mo)
		{
			mo.Vel = Vel;
			mo.target = self;
		}
	}

	void A_IceGuyLook()
	{
		A_Look();
		if (random[IceGuyLook]() < 64) SpawnWisp();
	}

	void A_IceGuyChase()
	{
		A_Chase();
		if (random[IceGuyLook]() < 128) SpawnWisp();
	}

	void A_IceGuyAttack()
	{
		if(!target) 
		{
			return;
		}
		SpawnMissileXYZ(Vec3Angle(radius / 2, angle + 90, 40.), target, "IceGuyFX");
		SpawnMissileXYZ(Vec3Angle(radius / 2, angle - 90, 40.), target, "IceGuyFX");
		A_PlaySound (AttackSound, CHAN_WEAPON);
	}
	
    // Death Wyvern
	private void DragonSeek (double thresh, double turnMax)
	{
		double dist;
		double delta;
		Actor targ;
		int i;
		double bestAngle;
		double angleToSpot, angleToTarget;
		Actor mo;

		targ = tracer;
		if(targ == null)
		{
			return;
		}

		double diff = deltaangle(angle, AngleTo(targ));
		delta = abs(diff);

		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (diff > 0)
		{ // Turn clockwise
			angle = angle + delta;
		}
		else
		{ // Turn counter clockwise
			angle = angle - delta;
		}
		VelFromAngle();

		dist = DistanceBySpeed(targ, Speed);
		if (pos.z + height < targ.pos.z || targ.pos.z + targ.height < pos.z)
		{
			Vel.Z = (targ.pos.z - pos.z) / dist;
		}
		if (targ.bShootable && random[DragonSeek]() < 64)
		{ // attack the destination mobj if it's attackable
			Actor oldTarget;
			
			if (absangle(angle, AngleTo(targ)) < 22.5)
			{
				oldTarget = target;
				target = targ;
				if (CheckMeleeRange ())
				{
					int damage = random[DragonSeek](1, 8) * 10;
					int newdam = target.DamageMobj (self, self, damage, 'Melee');
					target.TraceBleed (newdam > 0 ? newdam : damage, self);
					A_PlaySound (AttackSound, CHAN_WEAPON);
				}
				else if (random[DragonSeek]() < 128 && CheckMissileRange())
				{
					SpawnMissile(targ, "DragonFireball");		
					A_PlaySound (AttackSound, CHAN_WEAPON);
				}
				target = oldTarget;
			}
		}
		if (dist < 4)
		{ // Hit the target thing
			if (target && random[DragonSeek]() < 200)
			{
				Actor bestActor = null;
				bestAngle = 360.;
				angleToTarget = AngleTo(target);
				for (i = 0; i < 5; i++)
				{
					if (!targ.args[i])
					{
						continue;
					}
					ActorIterator iter = ActorIterator.Create(targ.args[i]);
					mo = iter.Next ();
					if (mo == null)
					{
						continue;
					}
					angleToSpot = AngleTo(mo);
					double diff = absangle(angleToSpot, angleToTarget);
					if (diff < bestAngle)
					{
						bestAngle = diff;
						bestActor = mo;
					}
				}
				if (bestActor != null)
				{
					tracer = bestActor;
				}
			}
			else
			{
				// [RH] Don't lock up if the dragon doesn't have any
				// targs defined
				for (i = 0; i < 5; ++i)
				{
					if (targ.args[i] != 0)
					{
						break;
					}
				}
				if (i < 5)
				{
					do
					{
						i = (random[DragonSeek]() >> 2) % 5;
					} while(!targ.args[i]);
					ActorIterator iter = ActorIterator.Create(targ.args[i]);
					tracer = iter.Next ();
				}
			}
		}
	}

	void A_DragonInitFlight()
	{
		ActorIterator iter = ActorIterator.Create(tid);

		do
		{ // find the first tid identical to the dragon's tid
			tracer = iter.Next ();
			if (tracer == null)
			{
				SetState (SpawnState);
				return;
			}
		} while (tracer == self);
		RemoveFromHash ();
	}

	void A_DragonFlight()
	{
		double ang;

		DragonSeek (4., 8.);
		if (target)
		{
			if(!target.bShootable)
			{ // target died
				target = null;
				return;
			}
			ang = absangle(angle, AngleTo(target));
			if (ang <22.5 && CheckMeleeRange())
			{
				int damage = random[DragonFlight](1, 8) * 8;
				int newdam = target.DamageMobj (self, self, damage, 'Melee');
				target.TraceBleed (newdam > 0 ? newdam : damage, self);
				A_PlaySound (AttackSound, CHAN_WEAPON);
			}
			else if (ang <= 20)
			{
				SetState (MissileState);
				A_PlaySound (AttackSound, CHAN_WEAPON);
			}
		}
		else
		{
			LookForPlayers (true);
		}
	}

	void A_DragonFlap()
	{
		A_DragonFlight();
		if (random[DragonFlight]() < 240)
		{
			A_PlaySound ("DragonWingflap", CHAN_BODY);
		}
		else
		{
			PlayActiveSound ();
		}
	}

	void A_DragonAttack()
	{
		SpawnMissile (target, "DragonFireball");
	}

	void A_DragonPain()
	{
		A_Pain();
		if (!tracer)
		{ // no destination spot yet
			SetState (SeeState);
		}
	}

	void A_DragonCheckCrash()
	{
		if (pos.z <= floorz)
		{
			SetStateLabel ("Crash");
		}
	}
	
	// Traductus
	void A_ClericAttack()
	{
		if (!target) return;

		Actor missile = SpawnMissileZ (pos.z + 40., target, "HolyMissile");
		if (missile != null) missile.tracer = null;	// No initial target
		A_PlaySound ("HolySymbolFire", CHAN_WEAPON);
	}

    // Menelkir	
	void MStaffSpawn2 (double angle)
	{
		Actor mo = SpawnMissileAngleZ (pos.z + 40, "MageStaffFX2", angle, 0.);
		if (mo)
		{
			mo.target = self;
			mo.tracer = RoughMonsterSearch(10, true, true);
		}
	}
	void A_MageAttack()
	{
		if (target == NULL)
		{
			return;
		}
		MStaffSpawn2(angle);
		MStaffSpawn2(angle - 5);
		MStaffSpawn2(angle + 5);
		A_PlaySound("MageStaffFire", CHAN_WEAPON);
	}

	// Zedek
	void A_FighterAttack()
	{
		if (!target) return;

		SpawnMissileAngle("FSwordMissile", Angle + (45. / 4), 0);
		SpawnMissileAngle("FSwordMissile", Angle + (45. / 8), 0);
		SpawnMissileAngle("FSwordMissile", Angle, 0);
		SpawnMissileAngle("FSwordMissile", Angle - (45. / 8), 0);
		SpawnMissileAngle("FSwordMissile", Angle - (45. / 4), 0);
		A_PlaySound ("FighterSwordFire", CHAN_WEAPON);
	}
    //*************************
    //*STRIFE-UNIQUE FUNCTIONS*
    //*************************
	// Acolyte
	void A_AcolyteDie ()
	{
		// [RH] Disable translucency here.
		A_SetRenderStyle(1, STYLE_Normal);

		// Only the Blue Acolyte does extra stuff on death.
		if (self is "AcolyteBlue")
		{
			int i;
			// Make sure somebody is still alive
			for (i = 0; i < MAXPLAYERS; ++i)
			{
				if (playeringame[i] && players[i].health > 0)
					break;
			}
			if (i == MAXPLAYERS)
				return;

			// Make sure all the other blue acolytes are dead, but do this only once in case of simultaneous kills.
			if (CheckBossDeath() && !players[i].mo.FindInventory("QuestItem7"))
			{
				players[i].mo.GiveInventoryType ("QuestItem7");
				players[i].SetLogNumber (14);
				A_StopSound (CHAN_VOICE);
				A_PlaySound ("svox/voc14", CHAN_VOICE);
			}
		}
	}

	void A_BeShadowyFoe()
	{
		A_SetRenderStyle(HR_SHADOW, STYLE_Translucent);
		bFriendly = false;
	}

	void A_AcolyteBits()
	{
		if (SpawnFlags & MTF_SHADOW)
		{
			A_BeShadowyFoe();
		}
		if (SpawnFlags & MTF_ALTSHADOW)
		{
			if (bShadow)
			{
				// I dunno.
			}
			else
			{
				A_SetRenderStyle(0, STYLE_None);
			}
		}
	}
	
	// Templar
	void A_TemplarAttack()
	{
		if (target != null)
		{
			A_PlaySound ("templar/shoot", CHAN_WEAPON);
			A_FaceTarget ();
			double pitch = AimLineAttack (angle, MISSILERANGE);

			for (int i = 0; i < 10; ++i)
			{
				int damage = (random[Templar]() & 4) * 2;
				double ang = angle + random2[Templar]() * (11.25 / 256);
				LineAttack (ang, MISSILERANGE+64., pitch + random2[Templar]() * (7.097 / 256), damage, 'Hitscan', "MaulerPuff");
			}
		}
	}

	// Inquisitor
	void A_InquisitorWalk ()
	{
		A_PlaySound ("inquisitor/walk", CHAN_BODY);
		A_Chase ();
	}

	private bool InquisitorCheckDistance ()
	{
		if (reactiontime == 0 && CheckSight (target))
		{
			return Distance2D (target) < 264.;
		}
		return false;
	}

	void A_InquisitorDecide ()
	{
		if (target == null)
			return;

		A_FaceTarget ();
		if (!InquisitorCheckDistance ())
		{
			SetStateLabel("Grenade");
		}
		if (target.pos.z != pos.z)
		{
			if (pos.z + height + 54 < ceilingz)
			{
				SetStateLabel("Jump");
			}
		}
	}

	void A_InquisitorAttack ()
	{
		if (target == null)
			return;

		A_FaceTarget ();

		AddZ(32);
		angle -= 45./32;
		Actor proj = SpawnMissileZAimed (pos.z, target, "InquisitorShot");
		if (proj != null)
		{
			proj.Vel.Z += 9;
		}
		angle += 45./16;
		proj = SpawnMissileZAimed (pos.z, target, "InquisitorShot");
		if (proj != null)
		{
			proj.Vel.Z += 16;
		}
		AddZ(-32);
	}

	void A_InquisitorJump ()
	{
		if (target == null)
			return;

		A_PlaySound ("inquisitor/jump", CHAN_ITEM, 1, true);
		AddZ(64);
		A_FaceTarget ();
		let localspeed = Speed * (2./3);
		VelFromAngle(localspeed);
		double dist = DistanceBySpeed(target, localspeed);
		Vel.Z = (target.pos.z - pos.z) / dist;
		reactiontime = 60;
		bNoGravity = true;
	}

	void A_InquisitorCheckLand ()
	{
		reactiontime--;
		if (reactiontime < 0 ||
			Vel.X == 0 ||
			Vel.Y == 0 ||
			pos.z <= floorz)
		{
			SetState (SeeState);
			reactiontime = 0;
			bNoGravity = false;
			A_StopSound (CHAN_ITEM);
			return;
		}
		A_PlaySound ("inquisitor/jump", CHAN_ITEM, 1, true);
	}

	void A_TossArm ()
	{
		Actor foo = Spawn("InquisitorArm", Pos + (0,0,24), ALLOW_REPLACE);
		if (foo != null)
		{
			foo.angle = angle - 90. + Random2[Inquisitor]() * (360./1024.);
			foo.VelFromAngle(foo.Speed / 8);
			foo.Vel.Z = random[Inquisitor]() / 64.;
		}
	}
	
	// Reaver
	void A_ReaverRanged ()
	{
		if (target != null)
		{
			A_FaceTarget ();
			A_PlaySound ("reaver/attack", CHAN_WEAPON);
			double bangle = Angle;
			double pitch = AimLineAttack (bangle, MISSILERANGE);

			for (int i = 0; i < 3; ++i)
			{
				double ang = bangle + Random2[ReaverAttack]() * (22.5 / 256);
				int damage = ((random[ReaverAttack]() & 7) + 1) * 3;
				LineAttack (ang, MISSILERANGE, pitch, damage, 'Hitscan', "StrifePuff");
			}
		}
	}

	// Crusader
	private bool CrusaderCheckRange ()
	{
		if (reactiontime == 0 && CheckSight (target))
		{
			return Distance2D (target) < 264.;
		}
		return false;
	}

	void A_CrusaderChoose ()
	{
		if (target == null)
			return;

		if (CrusaderCheckRange ())
		{
			A_FaceTarget ();
			angle -= 180./16;
			SpawnMissileZAimed (pos.z + 40, target, "FastFlameMissile");
		}
		else
		{
			if (CheckMissileRange ())
			{
				A_FaceTarget ();
				SpawnMissileZAimed (pos.z + 56, target, "CrusaderMissile");
				angle -= 45./32;
				SpawnMissileZAimed (pos.z + 40, target, "CrusaderMissile");
				angle += 45./16;
				SpawnMissileZAimed (pos.z + 40, target, "CrusaderMissile");
				angle -= 45./16;
				reactiontime += 15;
			}
			SetState (SeeState);
		}
	}

	void A_CrusaderSweepLeft ()
	{
		angle += 90./16;
		Actor misl = SpawnMissileZAimed (pos.z + 48, target, "FastFlameMissile");
		if (misl != null)
		{
			misl.Vel.Z += 1;
		}
	}

	void A_CrusaderSweepRight ()
	{
		angle -= 90./16;
		Actor misl = SpawnMissileZAimed (pos.z + 48, target, "FastFlameMissile");
		if (misl != null)
		{
			misl.Vel.Z += 1;
		}
	}

	void A_CrusaderRefire ()
	{
		if (target == null ||
			target.health <= 0 ||
			!CheckSight (target))
		{
			SetState (SeeState);
		}
	}

	void A_CrusaderDeath ()
	{
		if (CheckBossDeath ())
		{
			Floor_LowerToLowest(667, 8);
		}
	}

    // Sentinel
	void A_SentinelAttack (Class<Actor> missiletype = "SentinelFX2", string trailtype = "SentinelFX1")
	{
		// [BB] Without a target the P_SpawnMissileZAimed call will crash.
		if (!target)
		{
			return;
		}

		Actor missile = SpawnMissileZAimed (pos.z + 32, target, missiletype);

		if (missile != NULL && (missile.Vel.X != 0 || missile.Vel.Y != 0))
		{
			for (int i = 8; i > 1; --i)
			{
				Actor trail = Spawn(trailtype, Vec3Angle(missile.radius*i, missile.angle, 32 + missile.Vel.Z / 4 * i), ALLOW_REPLACE);
				if (trail != NULL)
				{
					trail.target = self;
					trail.Vel = missile.Vel;
					trail.CheckMissileSpawn (radius);
				}
			}
			missile.AddZ(missile.Vel.Z / 4);
		}
	}

	// Stalker
	void A_StalkerChaseDecide ()
	{
		if (!bNoGravity)
		{
			SetStateLabel("SeeFloor");
		}
		else if (ceilingz > pos.z + height)
		{
			SetStateLabel("Drop");
		}
	}

	void A_StalkerLookInit ()
	{
		State st;
		if (bNoGravity)
		{
			st = FindState("LookCeiling");
		}
		else
		{
			st = FindState("LookFloor");
		}
		if (st != CurState.NextState)
		{
			SetState (st);
		}
	}

	void A_StalkerDrop ()
	{
		bNoVerticalMeleeRange = false;
		bNoGravity = false;
	}

	void A_StalkerAttack ()
	{
		if (bNoGravity)
		{
			SetStateLabel("Drop");
		}
		else if (target != null)
		{
			A_FaceTarget ();
			if (CheckMeleeRange ())
			{
				int damage = (random[Stalker]() & 7) * 2 + 2;

				int newdam = target.DamageMobj (self, self, damage, 'Melee');
				target.TraceBleed (newdam > 0 ? newdam : damage, self);
			}
		}
	}

	void A_StalkerWalk ()
	{
		A_PlaySound ("stalker/walk", CHAN_BODY);
		A_Chase ();
	}
	
	// Programmer
	void A_ProgrammerMelee ()
	{
		if (target == null)
			return;

		A_FaceTarget ();

		if (!CheckMeleeRange ())
			return;

		A_PlaySound("programmer/clank", CHAN_WEAPON);

		int damage = ((random[Programmer]() % 10) + 1) * 6;
		int newdam = target.DamageMobj (self, self, damage, 'Melee');
		target.TraceBleed (newdam > 0 ? newdam : damage, self);
	}

	void A_SpawnProgrammerBase ()
	{
		Actor foo = Spawn("ProgrammerBase", Pos + (0,0,24), ALLOW_REPLACE);
		if (foo != null)
		{
			foo.Angle = Angle + 180. + Random2[Programmer]() * (360. / 1024.);
			foo.VelFromAngle();
			foo.Vel.Z = random[Programmer]() / 128.;
		}
	}

	void A_ProgrammerDeath ()
	{
		if (!CheckBossDeath ())
			return;

		for (int i = 0; i < MAXPLAYERS; ++i)
		{
			if (playeringame[i] && players[i].health > 0)
			{
				players[i].mo.GiveInventoryType ("ProgLevelEnder");
				break;
			}
		}
		// the sky change scripts are now done as special actions in MAPINFO
		A_BossDeath();
	}

	void A_SpotLightning()
	{
		if (target == null) return;

		Actor spot = Spawn("SpectralLightningSpot", (target.pos.xy, target.floorz), ALLOW_REPLACE);
		if (spot != null)
		{
			spot.threshold = 25;
			spot.target = self;
			spot.FriendPlayer = 0;
			spot.tracer = target;
		}
	}

	// Oracle
	void A_WakeOracleSpectre (Class<Actor> spawntype)
	{
		ThinkerIterator it = ThinkerIterator.Create(spawntype);
		Actor spectre = Actor(it.Next());

		if (spectre != NULL && spectre.health > 0 && self.target != spectre)
		{
			spectre.CurSector.SoundTarget = spectre.LastHeard = self.LastHeard;
			spectre.target = self.target;
			spectre.SetState (spectre.SeeState);
		}
	}
	
 States
 {
  Pain.Charm: 
    TNT1 A 0 
    { 
	 if (user_charmchance <= 0) { user_charmchance = 256; }
	 if (random(1,256) <= user_charmchance)
	 {
	  if(bFRIENDLY != 1)
	  {
       A_PlaySound("Munchies/Charmed"); 
       bFRIENDLY = 1; 
       Thing_ChangeTID(0,1000);
	  }
	 }
	 SetStateLabel("See");
    } 
  Pain.Heal1: 
    TNT1 A 0 
	{ 
	 ACS_NamedExecuteAlways("Healing_Actor",0,0); 
	 SetStateLabel("See");
	} 
  Pain.Heal2: 
    TNT1 A 0 
	{ 
	 ACS_NamedExecuteAlways("Healing_Actor",0,1); 
	 SetStateLabel("See");
    } 
  Pain.Heal3: 
    TNT1 A 0 
	{ 
	 ACS_NamedExecuteAlways("Healing_Actor",0,2); 
	 SetStateLabel("See");
    } 
  Pain.Heal4: 
    TNT1 A 0 
	{ 
	 ACS_NamedExecuteAlways("Healing_Actor",0,3); 
	 SetStateLabel("See");
    } 
  Pain.GravityHP:
    TNT1 A 0 
	{ 
	 ACS_NamedExecuteAlways("Hand-GravityAttack",0,0,0,0); 
	 SetStateLabel("See");
    } 
  Pain.GravityMP:
    TNT1 A 0
	{ 
	 ACS_NamedExecuteAlways("Hand-GravityAttack",0,1,0,0); 
	 SetStateLabel("See");
    } 
  Pain.GravityHPMP:
    TNT1 A 0
	{ 
	 ACS_NamedExecuteAlways("Hand-GravityAttack",0,2,0,0); 
	 SetStateLabel("See");
    } 
  Pain.Sceptre:
    TNT1 A 0 
	{
	 if (bFRIENDLY == 0) ACS_NamedExecuteAlways("AddSceptreEXP",0,0,0,10); // Increase EXP for Sceptre [1+(HP/300)]
	 SetStateLabel("Pain");
	}
  Death.Sceptre:
    TNT1 A 0
	{
	 if (bFRIENDLY == 0) ACS_NamedExecuteAlways("AddSceptreEXP",0,0,0,1); // Increase EXP for Sceptre [1+(HP/300)]
	 if (health <= user_HPXDeathRange) SetStateLabel("XDeath"); else SetStateLabel("Death");
	}
  Pain.Gauntlets:
    TNT1 A 0
	{
	 ACS_NamedExecuteAlways("SauronGauntletsHit",0,0,1,0); // Give some life when hurting a monster [1+(HP/500)]
	 SetStateLabel("Pain");
	}
  Death.Gauntlets:
    TNT1 A 0
	{
	 ACS_NamedExecuteAlways("SauronGauntletsHit",0,0,2,0); // Give some life when hurting a monster [1+(HP/500)]
	 if (health <= user_HPXDeathRange) SetStateLabel("XDeath"); else SetStateLabel("Death");
	}
 }
}

class MaulotaurBase : AetheriusMonsterZSC
{
 const MAULATORTICS = 25 * TICRATE;
 const MNTR_CHARGE_SPEED =13.;
 const MINOTAUR_LOOK_DIST = 16*54.;
	
	void MinotaurSlam (Actor target)
	{
		double ang = AngleTo(target);
		double thrust = 16 + random[MinotaurSlam]() / 64.;
		target.VelFromAngle(ang, thrust);
		int damage = random[MinotaurSlam](1, 8) * (bSummonedMonster? 4 : 6);
		int newdam = target.DamageMobj (null, null, damage, 'Melee');
		target.TraceBleedAngle (newdam > 0 ? newdam : damage, ang, 0.);
		if (target.player)
		{
			target.reactiontime = random[MinotaurSlam](14, 21);
		}
	}

	override void Tick ()
	{
		Super.Tick ();
		
		// The unfriendly Minotaur (Heretic's) is invulnerable while charging
		if (!bSummonedMonster)
		{
			bInvulnerable = bSkullFly;
		}
	}

	override bool Slam (Actor thing)
	{
		// Slamming minotaurs shouldn't move non-creatures
		if (!thing.bIsMonster && !thing.player)
		{
			return false;
		}
		return Super.Slam (thing);
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		damage = Super.DoSpecialDamage (target, damage, damagetype);
		if (damage != -1 && bSkullFly)
		{ // Slam only when in charge mode
			MinotaurSlam (target);
			return -1;
		}
		return damage;
	}

	void A_MinotaurAtk1()
	{
		if (!target)
		{
			return;
		}
		A_PlaySound ("minotaur/melee", CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = random[MinotaurAtk1](1, 8) * 4;
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			PlayerInfo player = target.player;
			if (player != null && player.mo == target)
			{ // Squish the player
				player.deltaviewheight = -16;
			}
		}
	}

	void A_MinotaurDecide()
	{
		bool friendly = bSummonedMonster;

		if (!target)
		{
			return;
		}
		if (!friendly)
		{
			A_PlaySound ("minotaur/sight", CHAN_WEAPON);
		}
		double dist = Distance2D(target);
		if (target.pos.z + target.height > pos.z
			&& target.pos.z + target.height < pos.z + height
			&& dist < (friendly ? 16*64. : 8*64.)
			&& dist > 1*64.
			&& random[MinotaurDecide]() < 150)
		{ // Charge attack
			// Don't call the state function right away
			SetStateLabel("Charge", true);
			bSkullFly = true;
			if (!friendly)
			{ // Heretic's Minotaur is invulnerable during charge attack
				bInvulnerable = true;
			}
			A_FaceTarget ();
			VelFromAngle(MNTR_CHARGE_SPEED);
			special1 = TICRATE/2; // Charge duration
		}
		else if (target.pos.z == target.floorz
			&& dist < 9*64.
			&& random[MinotaurDecide]() < (friendly ? 100 : 220))
		{ // Floor fire attack
			SetStateLabel("Hammer");
			special2 = 0;
		}
		else
		{ // Swing attack
			A_FaceTarget ();
			// Don't need to call P_SetMobjState because the current state
			// falls through to the swing attack
		}
	}
	
	void A_MinotaurCharge()
	{
		if (target == null)
		{
			return;
		}
		if (special1 > 0)
		{
			Class<Actor> type;

			if (gameinfo.gametype == GAME_Heretic)
			{
				type = "PhoenixPuff";
			}
			else
			{
				type = "PunchPuff";
			}
			Actor puff = Spawn (type, Pos, ALLOW_REPLACE);
			if (puff != null) puff.Vel.Z = 2;
			special1--;
		}
		else
		{
			bSkullFly = false;
			bInvulnerable = false;
			SetState (SeeState);
		}
	}

	void A_MinotaurAtk2()
	{
		bool friendly = bSummonedMonster;

		if (target == null)
		{
			return;
		}
		A_PlaySound ("minotaur/attack2", CHAN_WEAPON);
		if (CheckMeleeRange())
		{
			int damage = random[MinotaurAtk2](1, 8) * (friendly ? 3 : 5);
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			return;
		}
		double z = pos.z + 40;
		Class<Actor> fx = "MinotaurFX1";
		Actor mo = SpawnMissileZ (z, target, fx);
		if (mo != null)
		{
//			S_Sound (mo, CHAN_WEAPON, "minotaur/attack2", 1, ATTN_NORM);
			double vz = mo.Vel.Z;
			double ang = mo.angle;
			SpawnMissileAngleZ (z, fx, ang-(45./8), vz);
			SpawnMissileAngleZ (z, fx, ang+(45./8), vz);
			SpawnMissileAngleZ (z, fx, ang-(45./16), vz);
			SpawnMissileAngleZ (z, fx, ang+(45./16), vz);
		}
	}

	void A_MinotaurAtk3()
	{
		bool friendly = bSummonedMonster;

		if (!target)
		{
			return;
		}
		A_PlaySound ("minotaur/attack3", CHAN_VOICE);
		if (CheckMeleeRange())
		{
			int damage = random[MinotaurAtk3](1, 8) * (friendly ? 3 : 5);
			int newdam = target.DamageMobj (self, self, damage, 'Melee');
			target.TraceBleed (newdam > 0 ? newdam : damage, self);
			PlayerInfo player = target.player;
			if (player != null && player.mo == target)
			{ // Squish the player
				player.deltaviewheight = -16;
			}
		}
		else
		{
			if (Floorclip > 0 && compat_minotaur)
			{
				// only play the sound. 
				A_PlaySound ("minotaur/fx2hit", CHAN_WEAPON);
			}
			else
			{
				Actor mo = SpawnMissile (target, "MinotaurFX2");
				if (mo != null)
				{
					mo.A_PlaySound ("minotaur/attack1", CHAN_WEAPON);
				}
			}
		}
		if (random[MinotaurAtk3]() < 192 && special2 == 0)
		{
			SetStateLabel ("HammerLoop");
			special2 = 1;
		}
	}

	void A_MinotaurDeath()
	{
		if (Wads.CheckNumForName ("MNTRF1", Wads.ns_sprites) < 0 &&
			Wads.CheckNumForName ("MNTRF0", Wads.ns_sprites) < 0)
			SetStateLabel("FadeOut");
	}

	void A_MinotaurRoam()
	{
		// In case pain caused him to skip his fade in.
		A_SetRenderStyle(1, STYLE_Normal);

		let mf = MinotaurFriend(self);
		if (mf)
		{
			if (mf.StartTime >= 0 && (level.maptime - mf.StartTime) >= MAULATORTICS)
			{
				DamageMobj (null, null, TELEFRAG_DAMAGE, 'None');
				return;
			}
		}

		if (random[MinotaurRoam]() < 30)
			A_MinotaurLook();		// adjust to closest target

		if (random[MinotaurRoam]() < 6)
		{
			//Choose new direction
			movedir = random[MinotaurRoam]() % 8;
			FaceMovementDirection ();
		}
		if (!MonsterMove())
		{
			// Turn
			if (random[MinotaurRoam]() & 1)
				movedir = (movedir + 1) % 8;
			else
				movedir = (movedir + 7) % 8;
			FaceMovementDirection ();
		}
	}

	void A_MinotaurLook()
	{
		if (!(self is "MinotaurFriend"))
		{
			A_Look();
			return;
		}

		Actor mo = null;
		PlayerInfo player;
		double dist;
		Actor master = tracer;

		target = null;
		if (deathmatch)					// Quick search for players
		{
			for (int i = 0; i < MAXPLAYERS; i++)
			{
				if (!playeringame[i]) continue;
				player = players[i];
				mo = player.mo;
				if (mo == master) continue;
				if (mo.health <= 0) continue;
				dist = Distance2D(mo);
				if (dist > MINOTAUR_LOOK_DIST) continue;
				target = mo;
				break;
			}
		}

		if (!target)				// Near player monster search
		{
			if (master && (master.health > 0) && (master.player))
				mo = master.RoughMonsterSearch(20);
			else
				mo = RoughMonsterSearch(20);
			target = mo;
		}

		if (!target)				// Normal monster search
		{
			ThinkerIterator it = ThinkerIterator.Create("Actor");

			while ((mo = Actor(it.Next())) != null)
			{
				if (!mo.bIsMonster) continue;
				if (mo.health <= 0) continue;
				if (!mo.bShootable) continue;
				dist = Distance2D(mo);
				if (dist > MINOTAUR_LOOK_DIST) continue;
				if (mo == master || mo == self) continue;
				if (mo.bSummonedMonster && mo.tracer == master) continue;
				target = mo;
				break;			// Found actor to attack
			}
		}

		if (target)
		{
			SetState (SeeState, true);
		}
		else
		{
			SetStateLabel ("Roam", true);
		}
	}

	void A_MinotaurChase()
	{
		let mf = MinotaurFriend(self);
		if (!mf)
		{
			A_Chase();
			return;
		}


		// In case pain caused him to skip his fade in.
		A_SetRenderStyle(1, STYLE_Normal);

		if (mf.StartTime >= 0 && (level.maptime - mf.StartTime) >= MAULATORTICS)
		{
			DamageMobj (null, null, TELEFRAG_DAMAGE, 'None');
			return;
		}

		if (random[MinotaurChase]() < 30)
			A_MinotaurLook();		// adjust to closest target

		if (!target || (target.health <= 0) || !target.bShootable)
		{ // look for a new target
			SetIdle();
			return;
		}

		FaceMovementDirection ();
		reactiontime = 0;

		// Melee attack
		if (MeleeState && CheckMeleeRange ())
		{
			if (AttackSound)
			{
				A_PlaySound (AttackSound, CHAN_WEAPON);
			}
			SetState (MeleeState);
			return;
		}

		// Missile attack
		if (MissileState && CheckMissileRange())
		{
			SetState (MissileState);
			return;
		}

		// chase towards target
		if (!MonsterMove ())
		{
			NewChaseDir ();
			FaceMovementDirection ();
		}

		// Active sound
		if (random[MinotaurChase]() < 6)
		{
			PlayActiveSound ();
		}
	}	
}

class AetheriusBossZSC : AetheriusMonsterZSC
{
}